<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Class and Book Reviews</title>
    <link rel="stylesheet" href="/css/style.css">
  </head>
  <body>
    <nav class="home">
  <a href="/" >
    Home
  </a>
  <a href="/about.html" >
    About
  </a>
  <a href="/Resume.pdf" class="external" target="_blank">
    Resume <i class="fa fa-external-link" style="font-size:12px"></i>
  </a>
  <a href="https://github.com/aryzach" rel="noreferrer noopener" target="_blank">
    Github <i class="fa fa-external-link" style="font-size:12px"></i>
  </a>
</nav>

    <h1 class=postTitle>Class and Book Reviews</h1>
<p>16 Mar 2020 </p>

<p>This is a chronological listing and description of all resources I’ve used to learn STEM related things. Most of them are computer science and math resources. The resources include college classes, online MOOC-like classes, and books. It’s noted if I audited the class. None of the online courses were for credit, so you could say I audited those, too. I do all the exercises and projects included in the class or book listed, expect for some exceptions where noted. Most of the online classes I take come from an online computer science curriculum that tries to mimic a university CS degree equivalent. The classes are all free and largely project-based. I’ve really enjoyed the curriculum so far and highly recommend most of it. Here’s the link: <a href="https://github.com/ossu/computer-science">OSSU (Open Source Society University</a></p>

<h3 id="computer-science">Computer Science</h3>
<ul>
  <li><a href="##cs-50">CS 50</a></li>
  <li><a href="#introduction-to-programming">Introduction to programming</a></li>
  <li><a href="#how-to-design-programs">How to Design Programs</a></li>
  <li><a href="#networking">Networking</a></li>
  <li><a href="#machine-learning">Machine Learning</a></li>
  <li><a href="#learn-you-a-haskell">Learn You a Haskell</a></li>
  <li><a href="#software-construction">Software Construction</a></li>
  <li><a href="#programming-languages">Programming Languages</a></li>
  <li><a href="#prolog">Prolog</a></li>
  <li><a href="#discrete-math-(cs-dept)">Discrete Math (CS dept)</a></li>
  <li><a href="#git">Git</a></li>
  <li><a href="#intro-to-haskell">Intro to Haskell</a></li>
  <li><a href="#nand2tetris">Nand2Tetris (computer architecture)</a></li>
  <li><a href="#grad-level-programming-languages">Grad-level Programming Languages</a></li>
  <li><a href="#ai">AI</a></li>
</ul>

<h3 id="math">Math</h3>
<ul>
  <li><a href="#linear-algebra">Linear Algebra</a></li>
  <li><a href="#calculus">Calculus</a></li>
  <li><a href="#odes">ODEs</a></li>
  <li><a href="#Discrete Math (math dept)">Discrete Math (math dept)</a></li>
  <li><a href="#number-theory">Number Theory</a></li>
  <li><a href="#intro-to-real-analysis">Intro to Real Analysis</a></li>
  <li><a href="#abstract-algebra">Abstract Algebra</a></li>
</ul>

<h3 id="physical-science">Physical Science</h3>
<ul>
  <li><a href="#microbiology">Microbiology</a></li>
  <li><a href="#physics (mechanics)">Physics (mechanics)</a></li>
  <li><a href="#general-chemistry-II">General Chemistry II</a></li>
  <li><a href="#Physics (electromag)">Physics (electromag)</a></li>
  <li><a href="#neural-computation">Neural Computation</a></li>
</ul>

<h3 id="cs-50">CS 50</h3>
<h4 id="introduction-to-programming-online-edx---2017">Introduction to programming (online, edX) - 2017</h4>
<ul>
  <li><a href="https://docs.cs50.net/2017/fall/syllabus/cs50.html">2017 syllabus</a></li>
  <li><a href="https://www.edx.org/course/cs50s-introduction-to-computer-science">Current edX course</a></li>
</ul>

<p>The first class that got me hooked (on STEM and CS). I was looking for an intro to programming class online to get my feet wet. At this point I decided not to pursue business/accounting jobs and not to get my CPA. I knew I was interested in STEM, and that programming would a useful skill no matter what STEM field I went into.</p>

<p>The good: This class really opened my eyes to CS. I learned some data structures (arrays, linked lists, trees, hash tables), control structure (for, while, if-else, etc), pointers, recursion, function definitions, using functions, sorting and searching algorithms, memory, basic debugging, and all other things you’d expect out of an intro to programming class and more. Most of what I learned was through a lot of trial and error, this being both really beneficial and really frustrating. I think my first few projects had all of their functionality in the ‘main’ function, which in retrospect would still be very frustrating and difficult way to build something for anybody.</p>

<p>Two projects I remember:</p>
<ul>
  <li>Pyramid( int x ) prints a pyramid of height x made of character _.</li>
  <li>Cipher( string v, string s ) returns your string encrypted using a Vigenère cipher.</li>
</ul>

<p>The projects were fun and super challenging at the time.</p>

<p>The less good: The class was in C. In retrospect, this is kind of nuts, and they’ve since moved it to later in the curriculum. At the time, the class was perfect for me, because I was in the zone of determination and will. For somebody who’s not in that zone and just wants to learn ‘coding’, python would be a much better choice. While the idea of ‘strings are arrays with syntactic sugar’ and everything about pointers is useful and interesting, I can see how a lot of people would fall off the wagon here. I also found the edX discussions either lacking traffic, or just unhelpful. I resorted to reddit to ask a lot of questions, which wasn’t bad, and may have actually helped teach me out to ask better technical questions.
&lt;/p&gt;&lt;p&gt;
Originally, I was so motivated that I’d finish this 3-month, 8 project course in a few weeks. I ended up running into a lot of walls where I couldn’t debug something, and some of those projects ended up taking way longer, especially due to the back and forth on reddit, which can generally have 12-36 hour turnaround times depending on the question and momentum of the post. I did all the difficult-level problem sets instead of the easier ones, and I think it took me about 4 months. I skipped the python sections (recommended from online sources), and by the end was forcing myself to just spend an hour a day on it. But I still look fondly on my experience going through this class. It gave me a lot of confidence to move forward in the CS/programming world that was before so intimidating and foreign. I’d give myself an A in this class if you don’t grade on elegance of solutions.</p>

<h3 id="microbiology">Microbiology</h3>
<h4 id="microbiology-michigan-state-university---2017">Microbiology (Michigan State University) - 2017</h4>
<p>I took this class my last semester in college when I first thought ‘maybe I like/can do STEM.’ Microbiology is all about cycles, and ‘functions’ (read From Bacteria to Bach and Back by Dennett for the controversial use the of the word ‘function’ in the natural sciences).</p>

<p>While I retained little specific info, I enjoyed the process and readings, and gave me some context when thinking about more physical systems, and let me think about artificial processes more clearly (and other intelligent life may hardly separate the difference that we make between natural and artificial systems).</p>

<p>I think I 3.5’d this class (so B+/A-).</p>

<h3 id="linear-algebra">Linear Algebra</h3>
<h4 id="linear-algebra-city-colleges-of-chicago---2018">Linear Algebra (City Colleges of Chicago) - 2018</h4>
<p>This was my first math class since failing (then retaking and barely passing) Calc 2 roughly 4-5 years prior. I credit linear algebra and my professor for opening up my eyes to upper level math. While linear algebra is mostly computational, it has interesting ideas (the concept of spaces (4+ dimensional linear spaces), infinite spaces, transformations, determinant as volume, derivative as a linear transform, etc).</p>

<p><a href="https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">The Essence of Linear Algebra</a> by Grant Sanderson / 3blue1brown also got me exited and thinking about math</p>

<p>I wouldn’t still be interested (yet struggling) with higher-level math now if it hadn’t been for my linear algebra professor. He was truly patient and helpful with all of my questions. He introduced me to functional analysis and Hilbert spaces (but which I understand little about), and laid out the world of math for me.</p>

<p>I 4.0’d this class (A), but don’t remember a lot of the details, which is proving a little frustrating because my Abstract Algebra class now makes heavy use of properties of the some matrix groups for examples.</p>

<h3 id="physics-mechanics">Physics (mechanics)</h3>
<h4 id="physics-mechanics-city-colleges-of-chicago---2018">Physics (mechanics, City Colleges of Chicago) - 2018</h4>
<p>I took this as part of my interest in STEM, and also because I wanted to know how more things worked, and I never took physics in high school. I was very interested and worked hard to understand the topics as deep as I could. While it got me closer to first principles understanding of the world, at some point it gets hand-wavy and you can’t go much deeper without tools like analysis, topology, and PDE’s.</p>

<p>I 4.0’d the class (A).</p>

<h3 id="general-chemistry-ii">General Chemistry II</h3>
<h4 id="general-chemistry-ii-city-colleges-of-chicago---2018">General Chemistry II (City Colleges of Chicago) - 2018</h4>
<p>I also took this out of general interest. I learned how batteries work (kinda), and that while I enjoyed the labs in class, I don’t want to work in a lab. Also pushed me away from engineering and more towards math / CS.</p>

<p>I 4.0’d the class (A).</p>

<h3 id="calculus">Calculus</h3>
<h4 id="calculus-sequences-michigan-state-university-city-colleges-of-chicago---2012-to-2018">Calculus sequences (Michigan State University, City Colleges of Chicago) - 2012 to 2018</h4>
<p>First semester freshman year of college, I scraped by Calc I, and then failed Calc II second semester, retook Calc II over the summer at community college and barely passed. Then about 5 years later, I relearned a lot on my own (starting from trig and high school algebra). I used</p>

<p><a href="https://en.wikipedia.org/wiki/Calculus_Made_Easy">Calculus Made Easy</a> to relearn Calc I, because I never felt like I understood it when I took it. This book come highly recommended, but I didn’t find exceptionally different or enlightening. I think I actually learned it this time through because I applied myself, which is a lot more than I can say I did taking it 5 years prior. Then I took Calc II and III at City Colleges of Chicago. This endeavor was personal, because I remember it being so hard and defeating before.</p>

<p>Taking the time to actually practice the concepts and ask questions can do wonders. For anybody struggling with this, I definitely recommend community colleges because the professors and TAs are so much more personable and accessible (in my experience anyway).</p>

<p>After all that, I don’t really understand all the fuss about the calculus sequence, and think it’s probably really poorly taught most everywhere (because of the required curriculum, not because of the teachers).</p>

<p>I audited Calc II and officially took Calc III, which I got an A in.</p>

<h3 id="physics-electromag">Physics (electromag)</h3>
<h4 id="physics-electromag-city-colleges-of-chicago---2018">Physics (electromag, City Colleges of Chicago) - 2018</h4>

<p>This class was a lot of fun and a lot harder to wrap my head around, and left lots of open questions. When you bend an electron beam with a magnet, why do the different poles move the bean in different directions? I don’t remember the details, but I do remember it seeming suspiciously asymmetric at the time. I also watched a lot of Feynman lectures at the time, which got me thinking a lot about the fun of physics and education.</p>

<p>I 4.0’d the class (A).</p>

<h3 id="odes">ODEs</h3>
<h4 id="ordinary-differential-equations-city-colleges-of-chicago---2018">Ordinary Differential Equations (City Colleges of Chicago) - 2018</h4>

<p>I took this with the same professor who taught Linear Algebra (who I really like). Unfortunately, this class was just bad. It seems everybody has the same experience the first ODE class, where it’s just pattern matching on a superficial and non-mathematical level. I truly felt like I wasn’t doing math most of the time.</p>

<p>My professor told me the standard / required curriculum for ODE was made during Apollo Era (or maybe it was during the Manhattan Project), when they just needed a lot of competent, but not necessarily comprehending engineers to run all the numbers. This class is required for lots of engineering majors, but it needs to either be dropped or overhauled.</p>

<p>I 4.0’d the class (A), but don’t feel like I have any real understanding of ODE’s past the basics and how to solve them. I wish there was a discovery period in the class where, given some information, we uncovered the underlying ODE’s that were waiting to be solved. Actually, now that I remember, we did this once with a pendulum, but it wasn’t very enlightening.</p>

<h3 id="introduction-to-programming-python">Introduction to programming (python)</h3>
<h4 id="introduction-to-programming-online-edx---2019">Introduction to programming (online, edX) - 2019</h4>
<p><a href="https://www.edx.org/course/introduction-to-computer-science-and-programming-7">edX course</a> 
	Intro to programming (w/ python, edX) (link edx): I was wanting to take more online programming classes, but it had been almost a years since I last took CS 50, so I wanted a refresher, and wanted to learn python because I knew it was considered a more widely used language and more appropriate intro language. 
	The class is great for an intro class, and fairly breezy after taking the class that was taught in C. I believe this class started to get into OO design. Not much to say here other than I’d recommend this before CS 50 to most people. 
I would’ve gotten an A in the class.</p>

<h3 id="how-to-design-programs">How to Design Programs</h3>
<h4 id="how-to-design-programs-htdp-online-edx---2019">How to Design Programs (HtDP, online, edX) - 2019</h4>
<p><a href="https://www.edx.org/course/how-to-code-simple-data">edX course part 1 - How to Code: Simple Data</a> 
<a href="https://www.edx.org/course/how-to-code-complex-data">edX course part 2 - How to Code: Complex Data</a>
	At first I didn’t like this class because it seemed like a lot of just referencing design tables and tediously designing code that didn’t have much impact. But it turned out to be a really great class that taught about designing data, designing, functions, and designing programs. 
	I can’t say I had quite enough context at the time to fully appreciate the course, but it definitely left a mark, and I might have to revisit it in a few years after I have more design experience. It was taught in Racket (lisp dialect), and it was my first time writing functional code. It helped me write a lot more elegant solutions, utilize pattern matching and recursion a lot more elegantly and efficiently. I learned how to write data definitions, write tests and then write test-driven programs, understand the type of data / function / program I’m writing and match it to design patterns, write variations of recursive functions (tail recursive, cached, navigate graphs, etc), maintain state in a functional language, and much more. 
	The larger projects I remember were building a Sudoku solver using backtracking search, and building a space invaders game. Racket is a weird language because they give you strange language concepts like images as a primitive data type and the ‘big bang’ control structure, which was a little confusing to me at the time when trying to understand why images and other black box-like data types were primitives, and what that meant for a language. 
	When I was interning, I’d send myself screenshots of the problems / programs assigned, do them as best I could on a text editor at work, then email the files back to myself to run them at home. I would’ve gotten an A in the class.</p>

<h3 id="networking">Networking</h3>
<h4 id="intro-to-computer-networking-online-coursera---2019">Intro to Computer Networking (online, Coursera) - 2019</h4>
<p><a href="https://www.youtube.com/playlist?list=PLEAYkSg4uSQ2dr0XO_Nwa5OcdEcaaELSG">Coursera course</a>
	I can’t say I learned much from this course. It was a lot of lecture material, multiple choice chapter tests, and no programming exercises. They recommended getting familiar with WireShark (packet sniffer), but that guidance was pretty useless too. I suggested to the catalogue that compiles this CS curriculum to change the course and provide real programming assignments to go along with the course. They’ve since added 4 assignments (which I haven’t done yet), got rid of the chapter tests (which is a good thing in this case, because it was mostly all rote memorization), and suggest that the learner find a different networking course. 
	I took this class because I was interning in cybersecurity IT at NASA, and everybody around me knew networking really well, and I felt like an idiot because I didn’t know anything about it. My one big takeaway from this course is that dealing with internet traffic / moving a lot of data with limited resources on a large scale is a fun and math-y (but mostly solved) problem. The instructors did a great job presenting the problems and explaining the creative solutions people have come up with to deal with traffic problems (dealing with priority of data, bad actors, etc). The internet is truly an amazing utility-like infrastructure that’s gone through a lot of iterative changes and growing pains. 
	I probably would’ve gotten a C or D in this class. There were chapter tests that I guessed a lot on. If you’d like an excuse, the material was just so dry and not engaging. I’d like to go back and work through the assignments that have been posted since I finished the class.</p>

<h3 id="machine-learning">Machine Learning</h3>
<h4 id="machine-learning-online-coursera---2019">Machine Learning (online, Coursera) - 2019</h4>
<p><a href="https://www.coursera.org/learn/machine-learning">Coursera course</a> 
<a href="https://github.com/aryzach/MachineLearningClass">My code</a> 
	This class was strictly machine learning (mostly matrix learning) and not a general AI class. This was a really great introduction to the field and helped make all those buzzwords root themselves in something other than magic. 
	The course was taught in Matlab / Octave, and most of the project time went towards implementing the correct regression, back propagation, regularization, cost function, etc. techniques. I’ve forgotten many of the details, but would feel confident implementing something from this class with a little re-learning time. 
	Main topics: Linear regression with one variable, then with multiple variables, logistic regression, regularization, neural network concepts and training, advise for developers who are trying to build and/or train their own systems, support vector machines, unsupervised learning (k-means), anomaly detection, and recommender systems. The project I remember most was identifying handwritten digits using a neural net. Learning the details of things like how back propagation works can get fairly tedious, yet enlightening. 
	The main takeaways from this class are 1. It’s not magic, 2. Determine what type of problem you have (classification, regression) and apply one of these known solutions. Then by using meta-data that is tracking your training, determine how to better your model (usually more data or more independent parameters for regression and neural nets). 
	If you’re actually researching machine learning, I know improvements to models go much deeper into things like number of layers or altering the activation function, but this class was especially great because it enables people to fully build their own system for their application from scratch out of the gate. One of Andrew Ng’s (the professor and renowned ML researcher) gripes of ML is that people are doing too much academic research and not enough application, and this class both teaches from first principles and enables more applied ML use. 
	I would’ve gotten an A in the course, but most of the assignments were walkthroughs, so it’s not saying much. If I wanted to go into machine learning research, I’d probably retake parts of the course, and take another online ML class before I could say I’m a competent and confident machine-learning novice.</p>

<h3 id="learn-you-a-haskell">Learn You a Haskell</h3>
<h4 id="learn-you-a-haskell-book---2019">Learn You a Haskell (book) - 2019</h4>
<p><a href="http://learnyouahaskell.com">Book</a>
	I started reading this book before any PL class because I was interning (and I couldn’t find any more work!), and wanted to move forward with the CS curriculum, but couldn’t download anything that I needed to program (other option was learning more bash scripting). 
	Looking back, Haskell is a strange step for a beginner programmer to take, but it has informed and driven my learning more than a year later. This book is too long and detailed a resource but I guess that’s by necessity when the standard library is so massive. While it introduced me to some cool concepts (Maybe, Either, Monads), I wouldn’t recommend it as a first resource to learn Haskell (see the Haskell class below). I’ve since posted about this on OSSU, and they are replacing the book with the class below, and moving it back in the curriculum, so that it’s both not necessary and to be taken later.
	For some reason I was super intrigued in all of Haskell. I’ve always been a sucker for seemingly elite things, and Haskell is one of those things. I’d read that lifelong programmers would have enlightening breakthroughs after learning Haskell. Category theory and type theory / HoTT seemed so sexy (not that I understand them in the slightest). It seems like the furthest away from manipulating bits and physical state as you could get. I’m still drawn to it, but have only spent a little time using the language, and only slightly understand monads. But it did inspire me to take more math (notably algebra), and I hope to one day understand category theory and HoTT. (I’m currently taking algebra and a graduate level PL class where we learn Agda, which I think is interpreted by Haskell). Haskell is hard, especially as you go towards the land of functors, monoids, and monads. 
	I happy with what I learned while reading this, but have yet to finish the book (stopped around functors). If I finished it just to finish it, I’d be kidding myself, because I don’t really understand functors that well, and definitely don’t understand the monad abstraction, implementation, or use. There weren’t any exercises, but I’d give myself a C- on the whole book, a B+ on the parts I read, and hope that in the next year or so I’ll know Haskell with confidence.</p>

<h3 id="software-construction">Software Construction</h3>
<h4 id="software-construction-online-edx-2-parts---2019">Software Construction (online, edX, 2 parts) - 2019</h4>
<p><a href="https://www.edx.org/course/software-construction-object-oriented-design">Part 1 - Software Construction: Object-Oriented Design</a> 
<a href="https://www.edx.org/course/software-construction-data-abstraction">Part 2 - Software Construction: Data Abstraction</a> 
<a href="https://github.com/aryzach/SoftwareConstructionClass">A mess of my code from the class</a> 
	I didn’t have much confidence with OOP design before taking this class, and I’m still not as confident and seasoned as I’d like to be. This class helped only mildly with that feeling. Most of the projects I did required the following:</p>
<ul>
  <li>Understand what parts of the code are important for me to understand deeply, and what parts I could mostly ignore</li>
  <li>Add functionality, which usually required a form of deciding the correct way to refactor and abstract existing code, or implement a design pattern</li>
  <li>Debug unfamiliar code</li>
  <li>Create small OO applications from scratch 
  We also created UML diagrams and learned other methods to understand large OO code bases, and implemented a few design patterns (the visitor and decorator patterns are the only one I vaguely remember). 
  Overall, I learned to better read, understand, and work with existing code. I know that in most industry jobs, these skillsets are largely important, and I still would like a lot more practice on this front. I’d really like to start working on larger code bases, and also work through one of the design pattern books and apply the concepts to otherwise messy solutions. I’d also like to understand design patterns in functional languages. 
  Overall, I gained a little through this course, but wouldn’t recommend it to most people. Learning how to work with large code bases is a tricky thing to teach, because, I think, to teach it well, it takes a lot of time and lecture doesn’t really help. I think contributing to a project you care about, or building your own large project is the most effective way to learn to work with large amounts of code. Large code bases take a lot of time to read and fiddle, with large spaces of non-stimulating drudgery. This is a case where you just have to ‘put in the time,’ and that’s unlikely to happen with class projects, and better suited for projects you care about. 
  To conclude, this is an area that doesn’t bode well to class instruction, and is better suited for on-the-job learning or personal project discovery. I’ve yet to do either of those things, so this is definitely something I still struggle with. Because I had quite a bit of trouble with the last project (twitter mapper, here’s somebody elses description of it: https://github.com/MohamedMandouh/MyTwitterMapper/blob/master/README.md), I’d give myself a B/B- in the course.</li>
</ul>

<h3 id="programming-languages">Programming Languages</h3>
<h4 id="programming-languages-online-edx-3-parts---2019">Programming Languages (online, edX, 3 parts) - 2019</h4>
<p><a href="https://www.coursera.org/learn/programming-languages">Part A</a> 
<a href="https://www.coursera.org/learn/programming-languages-part-b">Part B</a><br />
<a href="https://www.coursera.org/learn/programming-languages-part-c">Part C</a> 
<a href="https://github.com/aryzach/ProgrammingLanguagesClass">My code</a> 
	Teaches type systems (dynamic vs static) and where along the spectrum different languages fall and why they fall there (notably SML, Racket, and Ruby). Discussion about the pros and cons of each, how different languages can be preferred depending on use, and specifically what language paradigms are preferred when prototyping vs. shipping a product (seems to be still up for discussion). 
	We also learned about how language semantics determine evaluation, how polymorphism works, about completeness vs. soundness, and about double dispatch. We compared languages by writing same code in different styles in the different languages. 
	The most interesting project was writing an interpreter for a small programming language in Racket, where we implemented language features such as closures, let expressions, function definitions, and function calls. This project was super challenging, but still accessible. It was especially difficult trying to understand the difference between Racket code and MUPL code (name of the small programming language), and the interplay between each of them. 
<a href="MUPL_Interpreter_Assignment.pdf">Interpreter assignment</a>
<a href="https://github.com/aryzach/ProgrammingLanguagesClass/blob/master/PartB/Week2/SmallLanguageInterpreter.rkt">Interpreter code written in Racket</a>
This and the HtDP series talked about above are some of my favorite classes so far. I would’ve gotten an A in this class.</p>
<h3 id="prolog">Prolog</h3>
<h4 id="prolog-book---2019">Prolog (book) - 2019</h4>
<p><a href="http://www.learnprolognow.org/">Learn Prolog Now! Book </a>
<a href="https://github.com/aryzach/Prolog">My Prolog coding exercises</a>
	I don’t really ‘get’ prolog even though I was able to do most (possibly all) the exercises for the half of the book I read. It just wasn’t very enlightening, and seemed like the same things possibly would’ve been easier in other languages. I only got about halfway through the book. I’d give myself an A for the part I did (was able to complete all but one of the many exercises), but a D for my understanding of Prolog overall.</p>

<h3 id="discrete-math-math-dept">Discrete Math (math dept)</h3>
<h4 id="discrete-math-ut-austin-math-dept-audit---2019">Discrete math (UT Austin, math dept, audit) - 2019</h4>
<p>I came to UT for a few reason, but one reason was that they had some math classes taught using the</p>

<p><a href="https://en.wikipedia.org/wiki/Moore_method">Moore Method</a></p>

<p>Possibly more on this later, but I’m excited about math education, and was really intrigued by this style. UChicago also offers a lot of classes like this, but it would’ve been less likely that I could’ve audited them.</p>

<p>Anyway, I took this class because I’d never taken proof-based math before and wasn’t confident in my abilities, and because it used the Moore Method. While I think the Moore Method was beneficial to our class, I don’t put it on a pedestal as I did before. 95% of the class time was spent either in groups of 3-6 students writing proofs on the blackboard, or individuals presenting their groups’ proof or homework proofs.</p>

<p>This class had a lot of overlap from the other discrete math class below, but with a much different perspective; it was a lot more methodical, exhaustive, and tedious. We focused a lot of time on the detail and semantics of the proofs, instead of the problem solving and bigger ideas behind the concepts. This class formalized a lot of concepts that I’ve been informally introduced to before, and gave me confidence in my knowledge of elementary set theory, and ability to write sound proofs. The most novel section for me was the part on equivalence relations.</p>

<p>I did most/all of the homework, but didn’t take any tests, and think I would’ve gotten an A.</p>

<h3 id="discrete-math-cs-dept">Discrete Math (CS dept)</h3>
<h4 id="discrete-math-ut-austin-cs-dept-audit---2019">Discrete math (UT Austin, CS dept, audit) - 2019</h4>

<p>I took this class because it’s in the standard CS curriculum, and I didn’t want to take it online.</p>

<p>This class was a lot of fun. I took it with my friend Dan, who took the class at a different school about 10 years ago. Most of the class was minimal memorization and just a lot of logic games. Some of the main topics were propositional logic, first-order logic, induction on natural numbers, induction on undirected simple graphs, combinatorics, and a primer on complexity/algorithms. The most interesting and fun parts were combinatorics and proving things about graphs.</p>

<p>I’d recommend a class like this to anybody that likes toying with games (including board games) and solving fun logic problems. Because there were so many instances in this class where you didn’t need to know much math, and the proofs / solutions were often just informal, creative, slightly out-of-the-box answers, I think the class is really accessible to lots of people. With some modification, I think you could teach parts of this course to intrigued middle schoolers.</p>

<p>As a fun, accessible example (after a short graph theory primer), why can’t each node of a undirected simple graph have a different order? Order being the number of other nodes that it’s connected to, and simple meaning that there’s at most one edge between nodes.</p>

<p>Here’s an online version that looks really similar to the one I took:</p>

<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/index.htm">Discrete Math</a></p>

<p>I was in the honors section of the class, which was filled with mostly excited freshman who are part of the Turing Scholars program at UT, so I was with smart, excited kids, but also felt old and out of place at 25. The one test I took in that class, I think I got 95%, and would’ve gotten an A overall.</p>

<h3 id="number-theory">Number Theory</h3>
<h4 id="number-theory-ut-austin-audit---2019">Number Theory (UT Austin, audit) - 2019</h4>
<p><a href="https://www.amazon.com/Elementary-Number-Theory-Its-Applications/dp/0201578891">Number Theory book we used</a><br />
	I took this class because I knew it had applications in CS, and because I wanted more practice with proof writing and mathematical thinking. Our class was only about nine people and our professor was excited to be able to work with a small group and move fast. We covered drastically more than the other number theory class, which was fun to work through, but also I got a little lost and behind at the end. 
	My class was all math majors, who most likely were able to pick up the material more quickly and gracefully than I was. It was cool to get exposed to things that aren’t normally in an intro to elementary number theory class (like the Dirichlet product), but it came at the expense of me not spending enough time on the fundamentals. Gaps in my understanding were quickly exposed, leading to a struggle for the second half of the class, and I still find myself getting stumped by some fundamental number theory problems that you’d expect a student who’s taken the class to be able to readily answer.
	I probably would’ve gotten a C- in this course, because I spent a lot of time on the homework and could mostly do it all without help, and would’ve done well on the tests in the first half of the course. He posted the test answers online, and I could only do about 50% of the questions with confidence on the later tests. I’d also recommend this course to non-math majors who are interested in and enjoy math, but don’t want to take analysis or algebra.</p>

<h3 id="intro-to-real-analysis">Intro to Real Analysis</h3>
<h4 id="intro-to-real-analysis-ut-austin-audit---2019">Intro to Real Analysis (UT Austin, audit) - 2019</h4>

<p>Analysis is super intimidating, but I wanted to know what it’s about. In this class we went slowly and only covered material through epsilon-delta / limits of functions. While I enjoyed the class, the material doesn’t seem as elegant and clean as algebra, so I’m a little turned off from analysis. That said, fields like topology, geometry, and high level algebra / type seem to make heavy use of analysis concepts, so I’m still pining to learn it so I can take those other classes without gaps in my knowledge.</p>

<p>Analysis seems to make heavy use of definitions, which gets tedious and wordy, but this may just be a side effect of an intro class. While I didn’t struggle in the class, I never felt completely satisfied. I would’ve gotten an A in the class.</p>

<h3 id="git">Git</h3>
<h4 id="git-online---2019">Git (online) - 2019</h4>

<p>I took a short git primer course (3 hours in total?). I knew the basics before, but didn’t know how to take advantage of it. Mainly, now I wish I separated my repositories by project instead of by class.</p>

<h3 id="intro-to-haskell">Intro to Haskell</h3>
<h4 id="introduction-to-haskell-online---2019">Introduction to Haskell (online) - 2019</h4>
<p><a href="https://www.seas.upenn.edu/~cis194/spring13/">Haskell lecture notes and assignments</a><br />
	I’d recommend this class for anybody who wants to learn Haskell, especially for somebody that has experience with some functional language prior. It’s concise, and works through the material quickly. I’m only about halfway through right now, but plan to finish it within the next few months. I’m excited to learn more about monads and actually use them to build something, which I believe this class offers.</p>

<h3 id="nand2tetris-computer-architecture">Nand2Tetris (computer architecture)</h3>
<h4 id="nand2tetris-computer-architecture-2-parts-online-edx---2020">Nand2Tetris (computer architecture, 2 parts, online, edX) - 2020</h4>
<p><a href="https://www.coursera.org/learn/build-a-computer">Part 1</a><br />
<a href="https://www.coursera.org/learn/nand2tetris2">Part 2</a><br />
<a href="https://www.nand2tetris.org/">Course book and website</a><br />
<a href="https://github.com/aryzach/nand2tetris">My code</a><br />
	Here we start with a nand gate as a primitive. Later we include a flip-flop as a primitive. From nand gates, we assemble many logic operators (and, or, multiplexor), and then build an ALU (arithmetic logic unit). Using the flip-flop (enables us to maintain state) we build bits, registers, and a series of RAM units. 
	With all this, we construct a computer with a screen display and keyboard. At this point, we can load and run binary programs. Then we write a VM translator from a stack-based VM language to assembly. We’re then introduced to a higher level language called Jack, which is like a lightweight C / Java-like language with classes, functions, methods, variables, fields, constructors, arrays, expressions, etc. We’re then supposed to develop a Jack to VM compiler, and then extend the functionality of our system by building an operating system.
	I’m nearly done with the Jack to VM compiler (written in python), which I hope to finish soon, and then move on to the OS. The compiler was a much bigger and more difficult task than I thought it would be, and it’s slowly starting to turn into spaghetti code, and there’s a lot of room for abstraction where I’m currently missing out on. Because it’s been a few months since I last worked on it, I may just start from scratch and use what I learned in the process to my own benefit. 
	I’m really excited to finish the course, and it’s definitely been eye opening and has uncovered what is seemingly magic. It’s also really hard to hold all the layers of abstraction in your head at the same time, especially at just my first pass at learning this material, so there’s definitely still some magic at play when thinking about how computers work. 
	Two ideas in this class hold me up:</p>
<ul>
  <li>Nand gates and flip-flops are primitives. I think I’d have to take a computer / electrical engineering or physic course to go deeper here</li>
  <li>The course assumes that we’re not writing the first assembler or compiler. To me, this is cheating a little bit, but I can see how that problem would be way to large for this course. Somehow, somebody built the first assembler using binary, and the first higher-level compiler using assembly (maybe FORTRAN or something similar?). Both projects sound huge, mind-bending, and powerful 
  I would give myself a B in this class. I’ve done all the work and feel confident in the material, but my VM translator and Jack to VM compiler don’t have the cleanest code. While they are bug-free so far, I want to redo these assignments to both understand the material better, and to become better at software design in general, but it’s time consuming, so I haven’t done that yet. If I had to extend one of these to include another feature, it would be a mess, and I’d probably resort to rewriting the program.
  Edit: I started to try to finish the course. All that was left was wrapping up the compiler and the OS chapter. Last time I worked on the compiler was two months ago. I started to relearn my code base, and think I could fairly easily add non-breaking features to finish it. The main problem I ran into was that I don’t remember the jack language that well. The specific problem was in this:</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">length</span> <span class="o">=</span> <span class="n">Keyboard</span><span class="p">.</span><span class="n">readInt</span><span class="p">(</span><span class="s">"How many numbers? "</span><span class="p">);.</span> 
</code></pre></div></div>

<p>I wasn’t sure how to handle the string expression. I could generate jack code to compile that would look something like:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">String</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">How</span> <span class="n">many</span> <span class="n">numbers</span><span class="o">?</span><span class="p">)</span>
<span class="n">let</span> <span class="n">length</span> <span class="o">=</span> <span class="n">Keyboard</span><span class="p">.</span><span class="n">readInt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<p>which I believe my current compiler could handle, but that’s a messy solution, and could easily cause other things to break and get messy. I don’t remember if there’s a more standard way to solve this in the VM language, because I need to push the string “How many numbers? “ onto the stack before calling ‘Keyboard.readInt 1’, but I don’t remember how to push a string, and I really didn’t spend much time trying to relearn the jack or VM specs. The second problem was that I was having trouble loading directories into the VM emulator, so I couldn’t test programs that spanned more than one class. I might have been doing something wrong / forgot how to do it, or something is wrong with the VM emulator program. I’m a little bummed that I’m giving up / ran into hurdles right now, because I was excited to finish and possibly refactor my compiler. It’s probably the biggest project I’ve done, and would give me good experience with edit old code, abstracting patterns, and refactoring. I also want my biggest project that I’ve worked hard on to be a finished project that I can show off (or at least be proud of).</p>

<p>I started reading the OS chapter, but decided not to finish. While I think I’d learn some things, it all seemed too tedious right now, and maybe someday I’ll revisit this (but unlikely if I’m being real). I think my time is better spent elsewhere right now, like getting deeper into Haskell, Agda, my AI class, or some larger software development experience. I’d also like to take the OS class eventually, and I’m sure that will overshadow anything I’d learn in this chapter.</p>

<h3 id="abstract-algebra">Abstract Algebra</h3>
<h4 id="abstract-algebra-ut-austin-audit---2020">Abstract Algebra (UT Austin, audit) - 2020</h4>
<p><a href="https://www.amazon.com/Algebra-2nd-Michael-Artin/dp/0132413779">Algebra by Artin</a><br />
	Both Haskell and a coworker at an internship inspired me to take algebra. Haskell is supposedly based on category theory, which requires more algebra, and my coworker had a PhD in CS, and solved this problem that we had be recognizing that the pattern could match that of a monoid (has an identity, and is associative). Seeing how applying the concept from algebra more easily solved this problem was impressive, and I wanted to know more. 
	I would guess that less than half CS majors take upper-level algebra, and a huge majority that work in software development don’t have a CS degree, so I wonder how many problems like this are out there, just waiting to be solved by an elegant application of some math concept.
	This class is hard. Often times when reading, I get lost in the weeds and lose the bigger picture; then when solving a problem, I often miss details that would’ve helped my solve it. I definitely struggling in the class, but I also missed two weeks of class because I was out of town. I thought I stayed caught up (by reading and doing HW on vacation), but I was still behind and mostly lost during lecture after that. We’re almost half way through the semester now. Spring break just started and the coronavirus ordeal is happening, so classes are going online for probably the next month or two. I’m just auditing the class, so I don’t have access online. This is kind of a blessing in disguise because I was getting overwhelmed in the class with new material and the gaps in my knowledge. So I’m going to cut my losses and plan to take it in the fall. 
	That said, I’ve still learned a lot about groups and had fun working with those concepts, and should be able to pick things up a lot more smoothly in the fall. I mostly like the book, but we started with the groups chapter, and my linear algebra is a little rusty, which the book relies heavily on for examples and exercises.
	With the material we’ve learned up until spring break, I’d give myself a C in the class.</p>

<h3 id="grad-level-programming-languages">Grad-level Programming Languages</h3>
<h4 id="graduate-level-programming-languages-ut-austin-audit---2020">Graduate-level Programming Languages (UT Austin, audit) - 2020</h4>
<p><a href="https://plfa.github.io/">Programming Language Foundations in Agda book</a><br />
<a href="https://github.com/aryzach/ProgrammingLanguageFoundationsInAgda-Part1">My code</a><br />
	I’m really excited about this class. We’re learning the programming language / proof assistant Agda. We’ve been following the book exactly, and I’ve done every problem in it so far. Even though classes are going online, and I’m just auditing (same issue as the algebra class above), I’m going to continue working through the book, and I think I’ll be able to get through it without much help. That said, Negation is the chapter I’m on right now, and it’s kicking my butt. My professor said he even had a really hard time with it, and just started really understanding it a few weeks ago.
	So far, the book has made me think about types a lot differently. I haven’t done much programming creating and using types before, but it makes me excited to. It’s a cool combination of programming, math, and logic. And it’s all interpreted (I think) by Haskell, and generally somewhat similar to Haskell, so I think it’ll make me a better Haskell developer. 
	So far in the class, I’d give myself an A. I’ll have to revisit this review when I finish the book (or get as far in the book as our prof. planned to, which I think is the Bisimulation chapter).</p>

<h3 id="ai">AI</h3>
<h4 id="ai-ut-austin-audit---2020">AI (UT Austin, audit) - 2020</h4>
<p><a href="http://aima.cs.berkeley.edu/">AI: A Modern Approach</a><br />
<a href="https://github.com/aryzach/AIClass">My code</a><br />
	I’ve only done ¼ of the projects, so I’ll have to revisit this later.</p>

<h3 id="neural-computation">Neural Computation</h3>
<h4 id="graduate-level-neural-computation-ut-austin-audit---2020">Graduate-level Neural Computation (UT Austin, audit) - 2020</h4>
<p><a href="https://github.com/alexhuth/neuralcomputation-sp2020">Neural Computation Syllabus</a><br />
	The first part of this course was super interesting. We learned about the brain mechanism owls use to track where a sound comes from on the horizontal axis (race condition that combines sound information from both ears, and uses the time delay from one ear to the other), and vertical axis (one ear tilts up in comparison to the other). We also learned how neurons want to maintain a certain firing rate, which is what causes tinnitus and phantom limb (inputs are shut off, so the brain fires those neurons to maintain a level of activity). 
	Professor Huth was an amazing professor for the short time I went to his class, and seems like a really good person in general. His work is really interesting, and he’s really passionate about it. Unfortunately, between me being out of town, and this coronavirus ordeal, I was only able to catch about a quarter of his class. While I’m really interested in his class, I wish I had a stronger background in AI/machine learning and statistics to be able to think about the material more deeply.</p>




  </body>
</html>
<script>

		// to remove space around images (bc they were wrapped with a <p> tag which adds padding/margin
		const allPTags = document.querySelectorAll("p");

		allPTags.forEach((elem) => {
				console.log(elem.childNodes[0].tagName);
				console.log(elem.parentNode);

				if (elem.childNodes.length === 1 && elem.childNodes[0].tagName === "IMG") {
						elem.parentNode.insertBefore(elem.childNodes[0], elem);
						elem.remove();
				}
		});
</script>


